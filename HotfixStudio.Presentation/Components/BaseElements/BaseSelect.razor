@using HotfixStudio.Infrastructure.PresentationData
@using HotfixStudio.Presentation.Components.BaseElements

@typeparam T

<div class="select-component @GetStatusClassString()" @onmouseenter="(() => isHovering = true)" @onmouseleave="(() => isHovering = false)">
    <BaseInput @bind-Value="inputValue" T="string" OnFocus="OnInputBaseFocusAsync" OnInputChanged="OnInputChangedAsync" Status="GetStatusClass()" />
    <div class="select-dropdown">
        @if (isLoading)
        {
            <div class="select-dropdown-message">
                Loading
            </div>
        }
        else if (optionResult?.TotalRows > 0)
        {
            @foreach (var option in optionResult.Options)
            {
                string selectedClass = GetSelectedClass(option.Key);
                <div class="select-dropdown-option @selectedClass" @onclick="(() => SelectValue(option))">
                    <div class="select-dropdown-option-label">
                        @option.Value
                    </div>
                    @if (displayDbValue)
                    {
                        <div class="select-dropdown-option-value">
                            @option.Key
                        </div>
                    }
                </div>
            }
        }
        else
        {
            <div class="select-dropdown-message">
                Nothing to see here
            </div>
        }
    </div>
</div>

@code {
    [CascadingParameter]
    public StackingContext StackingContext { get; set; }

    [Parameter]
    public List<T> Values { get; set; }

    [Parameter]
    public EventCallback<List<T>> ValuesChanged { get; set; }

    [Parameter]
    public Func<OptionSearch<T>, Task<OptionResult<T>>> GetOptionsAsync { get; set; }

    [Parameter]
    public bool Multiselect { get; set; }

    bool displayDbValue = true;

    bool isFocused = false;
    bool isHovering = false;

    bool readyToOpen = false;

    bool isLoading = false;
    int pageSize = 50;
    CancellationTokenSource? searchTokenSource;
    OptionSearch<T> optionSearch;
    OptionResult<T> optionResult;

    bool displayDbValueInInput = false;
    bool isComponentLoading = true;

    string inputValue = "";
    string lastVerifiedInputValue = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadComponentAsync();
        await base.OnInitializedAsync();
    }

    async Task OnInputBaseFocusAsync()
    {
        if (!isFocused)
        {
            readyToOpen = false;
            isFocused = true;
            isLoading = true;
            searchTokenSource = new();
            optionSearch = new(Values, pageSize, searchTokenSource.Token);
            var optionsTask = GetOptionsAsync(optionSearch);
            var delay = StackingContext.FocusContext(EventCallback.Factory.Create(this, Close), 200);
            await Task.Delay(delay);
            readyToOpen = true;
            if (optionsTask.IsCompleted)
            {
                optionResult = optionsTask.Result;
            }
            else
            {
                this.StateHasChanged();
                optionResult = await optionsTask;
            }
            isLoading = false;
            this.StateHasChanged();
        }
    }

    void Close()
    {
        searchTokenSource?.Cancel();
        isFocused = false;
        inputValue = lastVerifiedInputValue;
    }

    async Task OnInputChangedAsync(string input)
    {
        isLoading = true;
        searchTokenSource?.Cancel();
        searchTokenSource = new();
        var currentSearchToken = searchTokenSource.Token;
        optionSearch.Search = input;
        optionSearch.CancellationToken = currentSearchToken;

        try
        {
            optionResult = await GetOptionsAsync(optionSearch);
            if (!currentSearchToken.IsCancellationRequested)
            {
                isLoading = false;
            }
        }
        catch (OperationCanceledException)
        {
            // Task cancelled
        }
        catch (Exception ex)
        {
            isLoading = false;
            // TODO: Display error
        }
    }

    string GetStatusClassString()
    {
        if (readyToOpen)
        {
            var statusClass = GetStatusClass();
            return statusClass == ElementStatus.NONE ? "" : statusClass.ToString().ToLower();
        }
        return "";
    }

    string GetSelectedClass(T value)
    {
        return Values.Contains(value) ? "selected" : "";
    }

    ElementStatus GetStatusClass()
    {
        if (isComponentLoading)
            return ElementStatus.LOADING;
        else if (isFocused)
            return ElementStatus.FOCUS;
        else if (isHovering)
            return ElementStatus.HOVER;
        else
            return ElementStatus.NONE;
    }

    void SelectValue(KeyValuePair<T, string> option)
    {
        var value = option.Key;

        if (Multiselect)
        {
            if (Values.Contains(value))
            {
                Values.Remove(value);
            }
            else
            {
                Values.Add(value);
            }
            PrepareInputText(option);
        }
        else
        {
            if (Values.Any() && Values.First().Equals(value))
            {
                // No change
            }
            else
            {
                Values.Clear();
                Values.Add(value);
            }
            PrepareInputText(option);
            StackingContext.BlurContext();
        }

        ValuesChanged.InvokeAsync(Values);
    }

    void PrepareInputText(KeyValuePair<T, string> option)
    {
        if (Values.Count == 0)
        {
            lastVerifiedInputValue = "None";

        }
        else if (Values.Count == 1)
        {
            lastVerifiedInputValue =  displayDbValueInInput ? option.Key.ToString() : option.Value;
        }
        else
        {
            lastVerifiedInputValue = $"{Values.Count} selected";
        }
    }

    async Task LoadComponentAsync()
    {
        var tempKeyValuePair = new KeyValuePair<T, string>(default(T), "Temp");
        if(Values.Count == 1)
        {
            var tempOptionSearch = new OptionSearch<T>(Values, 1, CancellationToken.None);
            var tempOptionResult = await GetOptionsAsync(tempOptionSearch);
            tempKeyValuePair = tempOptionResult.Options.First();
        }
        PrepareInputText(tempKeyValuePair);
        inputValue = lastVerifiedInputValue;
        isComponentLoading = false;
    }
}
